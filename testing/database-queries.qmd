---
title: "Database Queries and Analysis"
output: html
---

## Introduction

The Demonax Tools Rust CLI provides commands for parsing game data and tracking player progress over time. This vignette demonstrates how to populate the database using the CLI and query it using SQL and R.

## Database Schema

The database contains tables organized by category:

### Player Data Tables (5)

- **players**: Player names and activity dates (id, name, first_seen, last_seen)
- **daily_snapshots**: Daily player stats (level, experience, magic_level, skills, equipment_json)
- **daily_quests**: Quest completion data per snapshot (quest_id, completion_count)
- **daily_bestiary**: Monster kill counts per snapshot (monster_id, kill_count)
- **daily_harvesting**: Harvesting progress per snapshot (race_id, harvest_count)

#### Understanding snapshot_id

The `snapshot_id` column in tables like `daily_quests`, `daily_bestiary`, and `daily_harvesting` is a foreign key that links back to a specific player snapshot.

**Relationship hierarchy**:
```
players
  └─ id (PK)
      └─ daily_snapshots
           └─ id (PK) ← This is what snapshot_id references
           └─ player_id (FK to players.id)
           └─ snapshot_date (the date of this snapshot)
           └─ level, experience, skills, equipment, etc.
                └─ daily_quests
                     └─ snapshot_id (FK to daily_snapshots.id)
                     └─ quest_id
                     └─ completion_count
```

**In simple terms**:
- Each player has multiple snapshots (one per date)
- Each snapshot captures the player's complete state at a specific point in time
- Each snapshot can have multiple quest/bestiary/harvesting entries showing progress

**Example query** - Get all quests for a specific player on a specific date:
```sql
SELECT q.quest_id, q.completion_count
FROM daily_quests q
JOIN daily_snapshots s ON q.snapshot_id = s.id
JOIN players p ON s.player_id = p.id
WHERE p.name = 'PlayerName' AND s.snapshot_date = '2026-01-24';
```

### Creature Data Tables (6)

- **creatures**: Monster definitions (race, name, hp, experience, type, article)
- **creature_loot**: Loot drop tables with chances (1-999 raw, calculated percentages)
- **creature_flags**: Boolean flags for creatures (e.g., CanPushItems, CanOpenDoors)
- **creature_skills**: Creature combat stats (HitPoints, GoStrength, FistFighting, etc.)
- **creature_spells**: Creature abilities and attacks (spell_name, damage_type, range, etc.)
- **item_loot_sources**: Reverse lookup of which creatures drop each item

### Item Data Tables (2)

- **items**: Item metadata (type_id, name, flags, attributes, rewarded_from)
- **item_prices**: NPC buy/sell prices (npc_name, price, mode)

### Game Content Tables (6)

- **quests**: Quest chest locations and rewards (name, chest_location, reward_items_json)
- **raids**: Raid event definitions and spawn compositions
- **spells**: Spell definitions (words, mana, level, spell_type, premium)
- **spell_teachers**: NPCs teaching spells (npc_name, spell_id, vocation, price, level_required)
- **rune_sellers**: NPCs selling runes/wands/rods (npc_name, item_id, price, item_category)
- **harvesting_data**: Harvesting recipes (tool_id, corpse_id, reward_id, percent_chance)

## R Integration

### Setup

```{r}
library(DBI)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(jsonlite)
library(purrr)
library(readr)

db <- dbConnect(RSQLite::SQLite(), "demonax-test.sqlite")

players <- dbReadTable(db, "players") |> as_tibble()
snapshots <- dbReadTable(db, "daily_snapshots") |> as_tibble()
bestiary <- dbReadTable(db, "daily_bestiary") |> as_tibble()
quests <- dbReadTable(db, "daily_quests") |> as_tibble()
harvesting <- dbReadTable(db, "daily_harvesting") |> as_tibble()
creatures <- dbReadTable(db, "creatures") |> as_tibble()
```

## Player Analysis

### Player Skills Analysis

```{r}
player_skills <- snapshots |>
  left_join(players, by = c("player_id" = "id")) |>
  filter(snapshot_date == "2026-01-07")

player_skills |>
  arrange(desc(level)) |>
  select(name, level, experience, magic_level)

exp_gains <- snapshots |>
  left_join(players, by = c("player_id" = "id")) |>
  arrange(name, snapshot_date) |>
  group_by(name) |>
  mutate(
    exp_gain = experience - lag(experience, default = 0),
    level_gain = level - lag(level, default = 0)
  ) |>
  filter(exp_gain > 0)

exp_gains |>
  ggplot(aes(x = as.Date(snapshot_date), y = exp_gain, color = name)) +
  geom_line() +
  labs(title = "Daily Experience Gains", x = "Date", y = "Experience")
```

### Bestiary Tracking

```{r}
player_bestiary <- bestiary |>
  left_join(snapshots, by = c("snapshot_id" = "id")) |>
  left_join(players, by = c("player_id" = "id")) |>
  left_join(creatures, by = c("monster_id" = "race")) |>
  select(player_name = name.x, snapshot_date, monster_id, monster_name = name.y, kill_count)

player_bestiary |>
  filter(player_name == "PlayerName") |>
  arrange(snapshot_date, monster_id)

player_bestiary |>
  group_by(player_name) |>
  summarize(
    total_kills = sum(kill_count),
    unique_monsters = n_distinct(monster_id)
  ) |>
  arrange(desc(total_kills))

player_bestiary |>
  filter(monster_id == 21) |>
  group_by(player_name) |>
  summarize(total_kills = sum(kill_count)) |>
  arrange(desc(total_kills))

latest_date <- max(snapshots$snapshot_date)
player_bestiary |>
  filter(snapshot_date == latest_date) |>
  arrange(player_name, monster_name)

player_bestiary |>
  filter(player_name == "PlayerName") |>
  group_by(snapshot_date) |>
  summarize(
    unique_monsters = n_distinct(monster_id),
    total_kills = sum(kill_count)
  ) |>
  ggplot(aes(x = as.Date(snapshot_date), y = unique_monsters)) +
  geom_line() +
  labs(title = "Bestiary Completion", x = "Date", y = "Unique Monsters")
```

### Harvesting Progress Tracking

```{r}
player_harvesting <- harvesting |>
  left_join(snapshots, by = c("snapshot_id" = "id")) |>
  left_join(players, by = c("player_id" = "id")) |>
  select(name, snapshot_date, race_id, harvest_count)

player_harvesting |>
  filter(name == "PlayerName") |>
  arrange(snapshot_date, race_id)

player_harvesting |>
  group_by(name) |>
  summarize(
    total_harvests = sum(harvest_count),
    unique_races = n_distinct(race_id)
  ) |>
  arrange(desc(total_harvests))

player_harvesting |>
  filter(race_id == 10) |>
  group_by(name) |>
  summarize(total_harvests = sum(harvest_count)) |>
  arrange(desc(total_harvests))
```

### Quest Analysis

```{r}
quest_data <- quests |>
  left_join(snapshots, by = c("snapshot_id" = "id")) |>
  left_join(players, by = c("player_id" = "id"))

quest_data |>
  group_by(quest_id) |>
  summarize(
    players = n_distinct(name),
    total_completions = sum(completion_count)
  ) |>
  arrange(desc(players))
```

### Equipment Analysis

```{r}
equipment_data <- snapshots |>
  left_join(players, by = c("player_id" = "id")) |>
  mutate(
    equipment = map(equipment_json, fromJSON),
    item_count = map_int(equipment, ~ sum(!is.na(.)))
  )

equipment_data |>
  arrange(desc(item_count)) |>
  select(name, snapshot_date, item_count)
```

## Creature and Loot Analysis

### Creature Statistics

```{r}
creatures <- dbReadTable(db, "creatures") |> as_tibble()
creature_loot <- dbReadTable(db, "creature_loot") |> as_tibble()

# Top creatures by experience
creatures |>
  select(name, article, type, experience, hp) |>
  arrange(desc(experience)) |>
  head(10)

# Count creatures by type
creatures |>
  count(type) |>
  arrange(desc(n))

# Bosses (empty article)
creatures |>
  filter(article == "") |>
  select(name, experience, hp) |>
  arrange(desc(experience))

# Regular creatures
creatures |>
  filter(article %in% c("a", "an")) |>
  select(name, article, experience, hp) |>
  arrange(desc(experience)) |>
  head(20)
```

### Loot Drop Analysis

```{r}
# Loot table for a specific creature
creature_loot |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(name == "demon") |>
  select(name, item_id, min_amount, max_amount, chance_raw, chance_percent) |>
  arrange(desc(chance_percent))

# Items with highest drop rates (>= 99%)
creature_loot |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(chance_percent >= 99) |>
  select(name, item_id, chance_percent) |>
  arrange(name, item_id)

# Ultra-rare drops (0.2% chance, raw = 1)
creature_loot |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(chance_raw == 1) |>
  select(name, item_id, chance_percent) |>
  arrange(name)

# Creatures with most loot variety
creature_loot |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  count(name, name = "loot_items") |>
  arrange(desc(loot_items)) |>
  head(10)
```

```{r}
# Loot chance distribution
loot_summary <- creature_loot |>
  group_by(creature_id) |>
  summarize(
    loot_items = n(),
    avg_chance = mean(chance_percent),
    guaranteed_drops = sum(chance_raw == 999)
  ) |>
  left_join(creatures, by = c("creature_id" = "id"))

loot_summary |>
  ggplot(aes(x = loot_items, y = avg_chance)) +
  geom_point(alpha = 0.6) +
  labs(title = "Creature Loot Tables",
       x = "Number of Loot Items",
       y = "Average Drop Chance %")

# Loot chance histogram
creature_loot |>
  ggplot(aes(x = chance_percent)) +
  geom_histogram(bins = 50) +
  labs(title = "Loot Drop Chance Distribution",
       x = "Drop Chance %",
       y = "Count")
```

**Note:** Loot chances range from 1-999 (raw values), corresponding to 0.2%-100% drop rates. The formula is: `(chance_raw + 1) / 999 * 100`.

### Creature Details (Skills, Spells, Flags)

Additional creature data is stored in separate tables for skills, spells, and flags.

```{r}
creature_skills <- dbReadTable(db, "creature_skills") |> as_tibble()
creature_spells <- dbReadTable(db, "creature_spells") |> as_tibble()
creature_flags <- dbReadTable(db, "creature_flags") |> as_tibble()

# Get all skills for a creature
creature_skills |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(name == "dragon") |>
  select(name, skill_name, skill_value) |>
  arrange(skill_name)

# Get all spells/attacks for a creature
creature_spells |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(name == "dragon") |>
  select(name, spell_name, spell_category, damage_type, min_value, max_value, range) 

# Creatures with specific flags
creature_flags |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(flag_name == "CanPushItems") |>
  select(name, flag_name) |>
  head(20)

# Most common creature flags
creature_flags |>
  count(flag_name, name = "creature_count") |>
  arrange(desc(creature_count))

# Spell types used by creatures
creature_spells |>
  count(spell_category) |>
  arrange(desc(n))
```

### Exporting Creature Data with Tidyverse

This example demonstrates how to extract comprehensive creature data using tidyverse operations instead of raw SQL queries. This approach reads each table separately and uses dplyr joins to combine them, which is more maintainable and easier to understand.

```{r}
# Read all creature-related tables
creatures_export <- dbReadTable(db, "creatures") |> as_tibble()
creature_spells_raw <- dbReadTable(db, "creature_spells") |> as_tibble()
creature_flags_raw <- dbReadTable(db, "creature_flags") |> as_tibble()
creature_skills_raw <- dbReadTable(db, "creature_skills") |> as_tibble()

# Join creature spells with creature info using dplyr
creature_spells_export <- creature_spells_raw |>
  inner_join(creatures_export, by = c("creature_id" = "id")) |>
  select(
    creature_name = name,
    hp,
    experience,
    type,
    spell_order,
    spell_name,
    spell_category,
    shape_name,
    range,
    area_size,
    angle,
    impact_name,
    damage_type,
    base_value,
    variation,
    speed_modifier,
    duration,
    summon_race_id,
    summon_count,
    priority,
    effect_id,
    missile_effect_id
  ) |>
  arrange(creature_name, spell_order)

# Join creature flags with creature names
creature_flags_export <- creature_flags_raw |>
  inner_join(creatures_export, by = c("creature_id" = "id")) |>
  select(creature_name = name, flag_name) |>
  arrange(creature_name, flag_name)

# Join creature skills with creature names
creature_skills_export <- creature_skills_raw |>
  inner_join(creatures_export, by = c("creature_id" = "id")) |>
  select(creature_name = name, skill_name, skill_value) |>
  arrange(creature_name, skill_name)

# Preview the exported data
head(creature_spells_export, 10)
head(creature_flags_export, 10)
head(creature_skills_export, 10)
```

### Item Loot Sources

The item_loot_sources table provides a reverse lookup to find which creatures drop each item.

```{r}
item_loot_sources <- dbReadTable(db, "item_loot_sources") |> as_tibble()

# Find all creatures that drop a specific item (e.g., gold coin = 3031)
item_loot_sources |>
  left_join(creatures, by = c("creature_id" = "id")) |>
  filter(item_id == 3031) |>
  select(name, drop_chance) |>
  arrange(desc(drop_chance))

# Items with most creature sources
item_loot_sources |>
  count(item_id, name = "source_count") |>
  arrange(desc(source_count)) |>
  head(20)
```

## Item and Economy Analysis

### Item Database

```{r}
items <- dbReadTable(db, "items") |> as_tibble()
item_prices <- dbReadTable(db, "item_prices") |> as_tibble()

# Most expensive items to buy from NPCs
item_prices |>
  left_join(items, by = c("item_id" = "type_id")) |>
  filter(mode == "buy") |>
  select(name, npc_name, price) |>
  arrange(desc(price)) |>
  head(20)

# Best selling prices (items NPCs will buy)
item_prices |>
  left_join(items, by = c("item_id" = "type_id")) |>
  filter(mode == "sell") |>
  select(name, npc_name, price) |>
  arrange(desc(price)) |>
  head(20)

# Quest reward items
items |>
  filter(!is.na(rewarded_from)) |>
  select(type_id, name, rewarded_from) |>
  arrange(type_id)

# Find NPCs trading a specific item (e.g., items with "sword" in name)
item_prices |>
  left_join(items, by = c("item_id" = "type_id")) |>
  filter(str_detect(name, regex("sword", ignore_case = TRUE))) |>
  select(npc_name, mode, price, name) |>
  arrange(price)
```

```{r}
# Price comparison analysis
price_comparison <- item_prices |>
  pivot_wider(
    id_cols = item_id,
    names_from = mode,
    values_from = price,
    values_fn = mean
  ) |>
  left_join(items, by = c("item_id" = "type_id"))

price_comparison |>
  filter(!is.na(buy) & !is.na(sell)) |>
  mutate(margin = buy - sell) |>
  arrange(desc(margin)) |>
  select(name, buy, sell, margin) |>
  head(20)

# Price distribution
item_prices |>
  ggplot(aes(x = price, fill = mode)) +
  geom_histogram(bins = 50) +
  scale_x_log10() +
  labs(title = "Item Price Distribution", x = "Price (log scale)", y = "Count")
```

## Spell and Magic System

### Spell Database

```{r}
spells <- dbReadTable(db, "spells") |> as_tibble()
spell_teachers <- dbReadTable(db, "spell_teachers") |> as_tibble()

# All spells sorted by level and mana
spells |>
  select(name, words, spell_type, level, mana, premium) |>
  arrange(level, mana)

# Most expensive spells to learn
spell_teachers |>
  left_join(spells, by = c("spell_id" = "id")) |>
  select(npc_name, name, words, price, vocation, level_required) |>
  arrange(desc(price)) |>
  head(20)

# NPCs teaching the most spells
spell_teachers |>
  count(npc_name, name = "spells_taught") |>
  arrange(desc(spells_taught))

# Spells by vocation
spell_teachers |>
  group_by(vocation) |>
  summarize(spell_count = n_distinct(spell_id)) |>
  arrange(desc(spell_count))

# Spells taught by a specific NPC
spell_teachers |>
  left_join(spells, by = c("spell_id" = "id")) |>
  filter(npc_name == "Elane") |>
  select(name, words, vocation, price, level_required) |>
  arrange(price)

# Premium vs free spells
spells |>
  count(premium, name = "spell_count")
```

```{r}
# Spell cost by level
spell_costs <- spell_teachers |>
  left_join(spells, by = c("spell_id" = "id"))

spell_costs |>
  ggplot(aes(x = level, y = price, color = vocation)) +
  geom_point(alpha = 0.6) +
  labs(title = "Spell Teaching Costs", x = "Level Required", y = "Price (gp)")

# Spells by type
spells |>
  count(spell_type) |>
  ggplot(aes(x = reorder(spell_type, n), y = n)) +
  geom_col() +
  coord_flip() +
  labs(title = "Spells by Type", x = "Spell Type", y = "Count")
```

### Rune and Wand/Rod Sellers

The rune_sellers table tracks NPCs that sell runes, wands, and rods.

```{r}
rune_sellers <- dbReadTable(db, "rune_sellers") |> as_tibble()

# All rune sellers sorted by category and price
rune_sellers |>
  select(npc_name, item_id, price, item_category, vocation) |>
  arrange(item_category, price)

# Count by category
rune_sellers |>
  count(item_category)

# Find where to buy a specific rune (e.g., item_id = 2268)
rune_sellers |>
  filter(item_id == 2268) |>
  select(npc_name, price, vocation, charges) |>
  arrange(price)
```

## Raid Events

```{r}
raids <- dbReadTable(db, "raids") |> as_tibble()

# All raids with frequency
raids |>
  select(name, type, interval_days, creatures, waves) |>
  arrange(interval_days)

# Cyclic raids (recurring events)
raids |>
  filter(type == "cyclic") |>
  select(name, interval_days, waves, message) |>
  arrange(interval_days)

# Raids by wave count
raids |>
  count(waves, name = "raid_count") |>
  arrange(desc(raid_count))
```

```{r}
# Raid frequency distribution
raids |>
  filter(!is.na(interval_days)) |>
  ggplot(aes(x = interval_days)) +
  geom_histogram(bins = 20) +
  labs(title = "Raid Frequency Distribution", x = "Interval (days)", y = "Count")
```

## Quest Locations

The quests table stores chest_location as a text field containing coordinates in the format "x,y,z (sector)".

```{r}
quest_locations <- dbReadTable(db, "quests") |> as_tibble()

# Parse chest_location into separate x, y, z columns
quest_locations <- quest_locations |>
  mutate(
    coords = str_extract(chest_location, "^[0-9]+,[0-9]+,[0-9]+"),
    x = as.integer(str_extract(coords, "^[0-9]+")),
    y = as.integer(str_extract(coords, "(?<=,)[0-9]+(?=,)")),
    z = as.integer(str_extract(coords, "[0-9]+$"))
  )
```

```{r}
# All quests with locations
quest_locations |>
  select(id, name, chest_location, reward_items_json) |>
  head(20)

# Quests containing specific reward item (item ID in JSON array, e.g., 3031 = gold)
quest_locations |>
  filter(str_detect(reward_items_json, "3031")) |>
  select(name, chest_location, reward_items_json) |>
  head(20)

# Count quests by Z level (using parsed coordinates)
quest_locations |>
  filter(!is.na(z)) |>
  count(z, name = "quest_count") |>
  arrange(desc(quest_count))
```

```{r}
# Quest distribution by floor (after parsing coordinates)
quest_locations |>
  filter(!is.na(z)) |>
  count(z) |>
  ggplot(aes(x = z, y = n)) +
  geom_col() +
  labs(title = "Quest Distribution by Floor", x = "Floor (Z)", y = "Quest Count")

# Quest map (X/Y coordinates)
quest_locations |>
  filter(z == 7) |>
  ggplot(aes(x = x, y = y)) +
  geom_point(alpha = 0.6) +
  labs(title = "Quest Locations (Floor 7)", x = "X Coordinate", y = "Y Coordinate")
```

## Harvesting Mechanics

This table contains harvesting recipes (game mechanics), not player harvesting progress.

```{r}
harvesting_recipes <- dbReadTable(db, "harvesting_data") |> as_tibble()
```

```{r}
# All harvesting recipes
harvesting_recipes |>
  select(tool_id, corpse_id, next_corpse_id, percent_chance, reward_id, race_id) |>
  arrange(desc(percent_chance))

# Recipes by tool
harvesting_recipes |>
  count(tool_id, name = "recipes")

# Find what rewards come from harvesting a specific corpse (e.g., 3101)
harvesting_recipes |>
  filter(corpse_id == 3101) |>
  select(corpse_id, reward_id, percent_chance) |>
  arrange(desc(percent_chance))
```

```{r}
# Harvesting success rate distribution
harvesting_recipes |>
  ggplot(aes(x = percent_chance)) +
  geom_histogram(bins = 20) +
  labs(title = "Harvesting Success Rate Distribution",
       x = "Success Rate %",
       y = "Count")
```

## Recreating Website Tables from Database

This section demonstrates how to recreate the same tables displayed on the Demonax website using the SQLite database instead of scattered CSV/TSV files. This is a proof-of-concept showing the database-driven approach.

**Prerequisites**: Run `DEV/testing/test-all-commands.sh` to populate the database with all game content.

**Note**: Some fields from the original website tables are not available in the database (e.g., vocation, quest_origin) or require additional computation from related tables.

### Group A: Player Data

#### Census / Player List

```{r}
# Read players and snapshots
census_players <- dbReadTable(db, "players") |> as_tibble()
census_snapshots <- dbReadTable(db, "daily_snapshots") |> as_tibble()

# Get latest snapshot per player
census <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  select(
    Name = name,
    Level = level,
    `Last Logged In` = snapshot_date
  ) |>
  arrange(desc(Level))

census |>
  DT::datatable(rownames = FALSE, class = "compact")
```

**Note**: The vocation field is not stored in the database.

#### Highscores

::: {.panel-tabset}

##### Experience

```{r}
highscore_exp <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(experience)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, Experience = experience)

highscore_exp |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Magic Level

```{r}
highscore_ml <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(magic_level)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, `Magic Level` = magic_level)

highscore_ml |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Axe Fighting

```{r}
highscore_axe <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(axe_fighting)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, `Axe Fighting` = axe_fighting)

highscore_axe |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Club Fighting

```{r}
highscore_club <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(club_fighting)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, `Club Fighting` = club_fighting)

highscore_club |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Sword Fighting

```{r}
highscore_sword <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(sword_fighting)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, `Sword Fighting` = sword_fighting)

highscore_sword |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Fist Fighting

```{r}
highscore_fist <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(fist_fighting)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, `Fist Fighting` = fist_fighting)

highscore_fist |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Distance Fighting

```{r}
highscore_dist <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(distance_fighting)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, `Distance Fighting` = distance_fighting)

highscore_dist |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Shielding

```{r}
highscore_shield <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(shielding)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, Shielding = shielding)

highscore_shield |>
  DT::datatable(rownames = FALSE, class = "compact")
```

##### Fishing

```{r}
highscore_fish <- census_snapshots |>
  group_by(player_id) |>
  filter(snapshot_date == max(snapshot_date)) |>
  ungroup() |>
  left_join(census_players, by = c("player_id" = "id")) |>
  arrange(desc(fishing)) |>
  mutate(Rank = row_number()) |>
  select(Rank, Name = name, Level = level, Fishing = fishing)

highscore_fish |>
  DT::datatable(rownames = FALSE, class = "compact")
```

:::

#### Killcount Overview

```{r}
killcount_bestiary <- dbReadTable(db, "daily_bestiary") |> as_tibble()
killcount_snapshots <- dbReadTable(db, "daily_snapshots") |> as_tibble()
killcount_creatures <- dbReadTable(db, "creatures") |> as_tibble()

# Get the latest snapshot date
latest_date <- max(killcount_snapshots$snapshot_date)

# Calculate yesterday kills (from latest date)
yesterday_kills <- killcount_bestiary |>
  left_join(killcount_snapshots, by = c("snapshot_id" = "id")) |>
  filter(snapshot_date == latest_date) |>
  group_by(monster_id) |>
  summarize(yesterday = sum(kill_count), .groups = "drop")

# Calculate total kills
total_kills <- killcount_bestiary |>
  group_by(monster_id) |>
  summarize(total = sum(kill_count), .groups = "drop")

# Join with creature names
killcount <- yesterday_kills |>
  full_join(total_kills, by = "monster_id") |>
  left_join(killcount_creatures, by = c("monster_id" = "id")) |>
  replace_na(list(yesterday = 0, total = 0)) |>
  select(
    `Creature Name` = name,
    `Yesterday Kills` = yesterday,
    `Total Kills` = total
  ) |>
  arrange(desc(`Total Kills`))

killcount |>
  DT::datatable(rownames = FALSE, class = "compact")
```

**Note**: The database does not track "killed-by" statistics (players killed by creatures).

### Group B: Game Content

#### Creature Overview

```{r}
creature_overview <- dbReadTable(db, "creatures") |> as_tibble()
creature_loot_data <- dbReadTable(db, "creature_loot") |> as_tibble()
creature_prices <- dbReadTable(db, "item_prices") |> as_tibble()
creature_items <- dbReadTable(db, "items") |> as_tibble()

# Calculate max sell price per item (what NPCs pay when players sell)
item_values <- creature_prices |>
  filter(mode == "sell") |>
  group_by(item_id) |>
  summarize(sell_value = max(price), .groups = "drop")

# Add fixed values for currency items
currency_values <- tibble(
  item_id = c(3031L, 3035L, 3043L),
  sell_value = c(1, 1000, 10000)
)

# Combine item values
all_item_values <- creature_items |>
  select(type_id) |>
  left_join(item_values, by = c("type_id" = "item_id")) |>
  left_join(currency_values, by = c("type_id" = "item_id")) |>
  mutate(value = coalesce(sell_value.y, sell_value.x, 0)) |>
  select(type_id, value)

# Calculate average loot value per creature
creature_avg_values <- creature_loot_data |>
  left_join(all_item_values, by = c("item_id" = "type_id")) |>
  mutate(
    avg_amount = (min_amount + max_amount) / 2,
    expected_value = (chance_percent / 100) * avg_amount * value
  ) |>
  group_by(creature_id) |>
  summarize(avg_value = sum(expected_value, na.rm = TRUE), .groups = "drop")

# Join with creatures and calculate metrics
creature_overview <- creature_overview |>
  left_join(creature_avg_values, by = c("id" = "creature_id")) |>
  mutate(
    avg_value = coalesce(avg_value, 0),
    value_per_exp = round(avg_value / experience, 3),
    value_per_hp = round(avg_value / hp, 3),
    value_per_exp_hp = round((value_per_exp + value_per_hp) / 2, 3)
  ) |>
  filter(article != "the") |>
  arrange(desc(experience)) |>
  select(
    Image = image_name,
    Name = html_name,
    Type = type,
    Hitpoints = hp,
    Experience = experience,
    `Average Value` = avg_value,
    `Value/Exp` = value_per_exp,
    `Value/HP` = value_per_hp,
    `Avg Value/Exp/HP` = value_per_exp_hp
  )

creature_overview |>
  DT::datatable(rownames = FALSE, class = "compact")
```

**Note**: Image column contains image filename, not rendered images.

#### Spell Overview

```{r}
spell_overview_spells <- dbReadTable(db, "spells") |> as_tibble()
spell_overview_teachers <- dbReadTable(db, "spell_teachers") |> as_tibble()
spell_overview_rune_sellers <- dbReadTable(db, "rune_sellers") |> as_tibble()
spell_overview_items <- dbReadTable(db, "items") |> as_tibble()

# Helper function to abbreviate spell words
abbreviate_words <- function(words) {
  parts <- str_split(words, " ")[[1]]
  if (length(parts) >= 2) {
    paste0(parts[1], parts[2], if(length(parts) > 2) paste(" ", paste(parts[3:length(parts)], collapse = " ")) else "")
  } else {
    words
  }
}

# Aggregate teachers by spell
teacher_agg <- spell_overview_teachers |>
  mutate(teacher_price = paste0(npc_name, " (", price, " gp)")) |>
  group_by(spell_id) |>
  summarize(
    teachers = paste(teacher_price, collapse = ", "),
    vocations = paste(unique(vocation), collapse = ", "),
    .groups = "drop"
  )

# TAB 1: Instant Spells (is_rune = 0)
instant_spells <- spell_overview_spells |>
  filter(is_rune == 0) |>
  left_join(teacher_agg, by = c("id" = "spell_id")) |>
  mutate(
    words_abbrev = sapply(words, abbreviate_words),
    Name = paste0(name, " (", words_abbrev, ")")
  ) |>
  select(
    Name,
    Type = spell_type,
    Vocation = vocations,
    Level = level,
    Mana = mana,
    Teacher = teachers
  ) |>
  arrange(Level, Mana)

# TAB 2: Rune Spells (is_rune = 1)
rune_spells <- spell_overview_spells |>
  filter(is_rune == 1) |>
  left_join(teacher_agg, by = c("id" = "spell_id")) |>
  mutate(
    words_abbrev = sapply(words, abbreviate_words),
    Name = paste0(name, " (", words_abbrev, ")")
  ) |>
  select(
    Name,
    Type = spell_type,
    Vocation = vocations,
    Level = level,
    Mana = mana,
    Teacher = teachers
  ) |>
  arrange(Level, Mana)

# TAB 3: Finished Runes (items with spell_id link)
rune_sellers_agg <- spell_overview_rune_sellers |>
  filter(item_category == "rune") |>
  mutate(seller_info = paste0(npc_name, " (", price, " gp for ", charges, " charges)")) |>
  group_by(item_id) |>
  summarize(buy_from = paste(seller_info, collapse = ", "), .groups = "drop")

finished_runes <- spell_overview_spells |>
  filter(is_rune == 1, !is.na(rune_type_id)) |>
  left_join(spell_overview_items, by = c("rune_type_id" = "type_id")) |>
  left_join(rune_sellers_agg, by = c("rune_type_id" = "item_id")) |>
  mutate(
    words_abbrev = sapply(words, abbreviate_words),
    Name = paste0(name.x, " (", words_abbrev, ")")
  ) |>
  select(
    Name,
    Type = spell_type,
    Level = level,
    Charges = charges,
    `Buy From` = buy_from
  ) |>
  arrange(Level)
```

::: {.panel-tabset}

## Instant Spells

```{r}
instant_spells |>
  DT::datatable(rownames = FALSE, class = "compact")
```

## Rune Spells

```{r}
rune_spells |>
  DT::datatable(rownames = FALSE, class = "compact")
```

## Finished Runes

```{r}
finished_runes |>
  DT::datatable(rownames = FALSE, class = "compact")
```

:::

**Note**: Vocation shows all vocations that can learn each spell. Finished runes are the physical rune items that can be purchased from NPCs.

#### Quest Overview

```{r}
quest_overview_quests <- dbReadTable(db, "quests") |> as_tibble()
quest_overview_items <- dbReadTable(db, "items") |> as_tibble()

# Load quest CSV for descriptions
quest_csv_path <- "asset/csv/quest.csv"
quest_descriptions <- read_csv(quest_csv_path, show_col_types = FALSE) |>
  select(quest_value, description = quest_legend) |>
  distinct(quest_value, .keep_all = TRUE)

quest_overview <- quest_overview_quests |>
  select(-description) |>  # Remove empty description column from database
  # Join with CSV descriptions using quest ID
  left_join(quest_descriptions, by = c("id" = "quest_value")) |>
  mutate(
    reward_ids = map(reward_items_json, ~ fromJSON(.) %||% integer(0)),
    reward_names = map(reward_ids, function(ids) {
      if (length(ids) == 0) return(character(0))
      quest_overview_items |>
        filter(type_id %in% ids) |>
        pull(name)
    })
  ) |>
  group_by(name, description) |>
  summarize(
    chest_locations = paste(chest_location, collapse = "; "),
    all_rewards = list(unlist(reward_names)),
    .groups = "drop"
  ) |>
  mutate(
    rewards = map_chr(all_rewards, function(r) {
      unique_rewards <- unique(r)
      paste(unique_rewards, collapse = ", ")
    })
  ) |>
  select(
    Name = name,
    Description = description,
    `Chest Location` = chest_locations,
    Rewards = rewards
  ) |>
  arrange(Name)

quest_overview |>
  DT::datatable(rownames = FALSE, class = "compact")
```

**Note**: Database lacks quest_origin (classic vs demonax) and level_rec fields.

#### Raid Overview

```{r}
raid_overview <- dbReadTable(db, "raids") |> as_tibble()
raid_creatures <- dbReadTable(db, "creatures") |> as_tibble()

raid_overview <- raid_overview |>
  mutate(
    spawn_data = map(spawn_composition_json, ~ fromJSON(.) %||% data.frame()),
    creatures_formatted = map_chr(spawn_data, function(spawns) {
      if (nrow(spawns) == 0) return("Unknown")
      # spawns is a data frame with columns: race, min, max
      apply(spawns, 1, function(row) {
        race_id <- as.integer(row["race"])
        min_count <- as.integer(row["min"])
        max_count <- as.integer(row["max"])

        creature_name <- raid_creatures |>
          filter(race == race_id) |>
          pull(name) |>
          first()

        if (is.na(creature_name) || length(creature_name) == 0) {
          creature_name <- paste("Race", race_id)
        } else {
          creature_name <- str_to_title(creature_name)
        }

        if (min_count == max_count) {
          paste(min_count, creature_name)
        } else {
          paste(min_count, "to", max_count, creature_name)
        }
      }) |> paste(collapse = ", ")
    })
  ) |>
  select(
    Name = name,
    Type = type,
    `Interval Days` = interval_days,
    Waves = waves,
    Message = message,
    Creatures = creatures_formatted
  ) |>
  arrange(`Interval Days`, Name)

raid_overview |>
  DT::datatable(rownames = FALSE, class = "compact")
```

#### Item Overview

```{r}
item_overview_items <- dbReadTable(db, "items") |> as_tibble()
item_overview_prices <- dbReadTable(db, "item_prices") |> as_tibble()
item_overview_loot <- dbReadTable(db, "item_loot_sources") |> as_tibble()
item_overview_creatures <- dbReadTable(db, "creatures") |> as_tibble()

# Aggregate prices by item and mode
price_agg <- item_overview_prices |>
  mutate(npc_price = paste0(npc_name, " (", price, " gp)")) |>
  group_by(item_id, mode) |>
  summarize(npcs = paste(npc_price, collapse = ", "), .groups = "drop") |>
  pivot_wider(names_from = mode, values_from = npcs)

# Aggregate loot sources
loot_agg <- item_overview_loot |>
  left_join(item_overview_creatures, by = c("creature_id" = "id")) |>
  group_by(item_id) |>
  summarize(lootable_from = paste(str_to_title(name), collapse = ", "), .groups = "drop")

# Parse item attributes
item_attrs <- item_overview_items |>
  filter(!is.na(attributes) & attributes != "{}") |>
  rowwise() |>
  mutate(
    attr_list = list(tryCatch(fromJSON(attributes), error = function(e) list())),
    # Extract weight - handle both "Weight" and "{Weight" keys
    weight_attr = {
      w <- attr_list[["Weight"]] %||% attr_list[["{Weight"]]
      if (!is.null(w)) as.numeric(gsub("[^0-9]", "", w)) else NA_real_
    },
    # Extract attack value
    attack = {
      a <- attr_list[["WeaponAttackValue"]] %||% attr_list[["ThrowAttackValue"]]
      if (!is.null(a)) as.numeric(gsub("[^0-9]", "", a)) else NA_real_
    },
    # Extract defense value
    defense = {
      d <- attr_list[["WeaponDefendValue"]] %||% attr_list[["ShieldDefendValue"]] %||% attr_list[["ThrowDefendValue"]]
      if (!is.null(d)) as.numeric(gsub("[^0-9]", "", d)) else NA_real_
    },
    # Extract armor value
    armor = {
      a <- attr_list[["ArmorValue"]]
      if (!is.null(a)) as.numeric(gsub("[^0-9]", "", a)) else NA_real_
    }
  ) |>
  select(type_id, weight_attr, attack, defense, armor)

# Combine all data
item_overview <- item_overview_items |>
  left_join(price_agg, by = c("type_id" = "item_id")) |>
  left_join(loot_agg, by = c("type_id" = "item_id")) |>
  left_join(item_attrs, by = "type_id") |>
  mutate(
    # Format weight in oz (divide by 100, since stored in centipounds)
    weight_oz = if_else(!is.na(weight_attr), round(weight_attr / 100, 1), NA_real_)
  ) |>
  select(
    Image = image_link,
    Name = name,
    Weight = weight_oz,
    Attack = attack,
    Defense = defense,
    Armor = armor,
    Description = description,
    `Rewarded From` = rewarded_from,
    `Lootable From` = lootable_from,
    `Sell To` = sell,
    `Buy From` = buy
  ) |>
  arrange(Name)

item_overview |>
  DT::datatable(rownames = FALSE, class = "compact")
```

**Note**: Image column contains filename/path, not rendered images.

#### Item and Economy Analysis

Parse all attributes from the items table into a wide-format dataframe.

```{r}
# Load items
items_raw <- dbReadTable(db, "items") |> as_tibble()

# Parse attributes for all items
items_with_attrs <- items_raw |>
  filter(!is.na(attributes) & attributes != "{}") |>
  rowwise() |>
  mutate(
    # Parse JSON (now clean thanks to parser fix!)
    parsed_attrs = list(
      tryCatch(fromJSON(attributes), error = function(e) list())
    )
  ) |>
  ungroup() |>
  unnest_wider(parsed_attrs, names_sep = "_") |>
  # Rename to remove prefix
  rename_with(~gsub("parsed_attrs_", "", .x), starts_with("parsed_attrs_")) |>
  # Convert numeric strings to actual numbers for attribute columns
  mutate(across(
    where(is.character) & !any_of(c("name", "description", "flags", "image_link", "rewarded_from")),
    ~suppressWarnings(as.numeric(.x))
  ))

# Display comprehensive table
items_with_attrs |>
  select(type_id, name, everything(), -id, -attributes, -flags, -image_link) |>
  DT::datatable(
    rownames = FALSE,
    class = "compact",
    filter = "top",
    options = list(
      scrollX = TRUE,
      pageLength = 50,
      columnDefs = list(
        list(width = '150px', targets = 1)  # Name column
      )
    )
  )
```

#### Harvesting Overview

```{r}
harvesting_overview_data <- dbReadTable(db, "harvesting_data") |> as_tibble()
harvesting_overview_items <- dbReadTable(db, "items") |> as_tibble()

harvesting_overview <- harvesting_overview_data |>
  left_join(
    harvesting_overview_items |> select(type_id, tool_name = name),
    by = c("tool_id" = "type_id")
  ) |>
  left_join(
    harvesting_overview_items |> select(type_id, corpse_name = name),
    by = c("corpse_id" = "type_id")
  ) |>
  left_join(
    harvesting_overview_items |> select(type_id, reward_name = name),
    by = c("reward_id" = "type_id")
  ) |>
  select(
    Tool = tool_name,
    Corpse = corpse_name,
    `Next Corpse ID` = next_corpse_id,
    `Chance %` = percent_chance,
    Reward = reward_name
  ) |>
  arrange(desc(`Chance %`))

harvesting_overview |>
  DT::datatable(rownames = FALSE, class = "compact")
```

### Skipped Examples

The following website tables cannot be recreated from the database:

- **Misc Overview**: No clear definition of which items are "miscellaneous"
- **House Overview**: No house data in database
- **Deaths Overview**: No death tracking in database
- **Milestone Overview**: No milestone tracking in database
- **Equipment Overview**: Would require parsing attributes JSON to determine body position (helmets, necklaces, armors, shields, legs, boots, rings, bags)
- **Weapon Overview**: Would require parsing attributes JSON to identify weapons and weapon types

## Closing Database Connection

```{r}
dbDisconnect(db)
```

## USR File Format

The .usr files contain player data in the following format:

```
ID              = 100001
Name            = "PlayerName"
...
Skill = (0,108,0,1,0,0,0,0,0,0,1,20000100,0,20426400,100)  # Level/Exp
Skill = (1,75,0,1,0,0,0,0,0,0,1,20000100,0,20426400,100)   # Magic Level
...
QuestValues = {(20,1),(25,1),(227,5)}
Bestiary    = {(15,8),(21,6),(27,3)}
Harvesting  = {(10,5),(15,3),(20,1)}
Inventory   = {3 Content={5272}, 10 Content={2854}}
```

## Session Info

```{r, eval = TRUE}
sessionInfo()
```
